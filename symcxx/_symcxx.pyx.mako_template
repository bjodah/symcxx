# -*- coding: utf-8 -*-
# distutils: language = c++
# distutils: extra_compile_args = -std=c++11 -I./include

<%doc>
# This is a templated source file.
# Render template using Mako (Python templating engine)
</%doc>
# ${_message_for_rendered}

from libcpp cimport bool
from libcpp.vector cimport vector
from libcpp.string cimport string
from libcpp.memory cimport unique_ptr

ctypedef unsigned int idx_t

import itertools
import sys

from cython.operator import dereference as deref
import numpy as np

# TODO: use create(..., ) rather than raw methods. (will require C api)

cdef extern from "symcxx/core.hpp" namespace "symcxx":
    cdef cppclass NameSpace:
        idx_t n_symbs

        const idx_t pi_id
        const idx_t neg_pi_id
        const idx_t e_id
        const idx_t neg_e_id

        NameSpace(idx_t)
        idx_t make_symbol(idx_t) except +
        idx_t make_integer(int)
        idx_t make_float(double)
        idx_t make_nan()
        idx_t make_matrix(idx_t, idx_t, vector[idx_t]) except +
        idx_t matrix_jacobian(idx_t, idx_t) except +
        void matrix_evalf(idx_t, const double * const, double * const) except +
        idx_t matrix_get_nr(idx_t) const
        idx_t matrix_get_nc(idx_t) const
        string print_ast(const idx_t, vector[string]&) except +

        unique_ptr[NameSpace] rebuild_from_matrix(const vector[idx_t]&, idx_t)
        idx_t get_instances_size()
        bool evalb(idx_t, const double *) except +
        double evalf(idx_t, const double *) except +
        idx_t diff(const idx_t, const idx_t) except +

%for Cls, Parent, meth in types_nonatomic_unary:
        idx_t ${meth}(idx_t)
%endfor

%for Cls, Parent, meth in types_nonatomic_binary:
        idx_t ${meth}(idx_t, idx_t)
%endfor

    cdef unique_ptr[NameSpace] make_unique_NameSpace(const idx_t)


cdef class _Matrix(object):

    cdef readonly idx_t idx
    cdef readonly object ns
    cdef public object flat_output

    def __init__(self, idx_t idx, namespace, flat_output=False):
        self.idx = idx
        self.ns = namespace
        self.flat_output = flat_output

    @property
    def shape(self):
        return (self.ns.matrix_get_nr(self.idx),
                self.ns.matrix_get_nc(self.idx))

    def jacobian(self, other):
        return _Matrix(self.ns.matrix_jacobian(self.idx, other.idx), self.ns)

    def evalf(self, inp, out=None):
        if out is None:
            out = np.empty(self.shape)
        local_out = np.ravel(out)
        self.ns.matrix_evalf(self.idx, np.asarray(inp, dtype=np.float64), local_out)
        if self.flat_output:
            return local_out
        else:
            return local_out.reshape(self.shape)


class _IndexedObject(object):

    def __init__(self, idx, namespace, **kwargs):
        self.idx = idx
        self.ns = namespace
        self.__dict__.update(kwargs)

    def __eq__(self, other):
        other = _implicit_conversion(self.ns, other)
        if self.idx == other.idx and self.ns == other.ns:
            return True
        else:
            return False

    def __str__(self):
        return self.ns.print_ast(self.idx).decode('utf-8')

    def __add__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Add2(self.idx, other.idx), self.ns)

    def __radd__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Add2(other.idx, self.idx), self.ns)

    def __sub__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Sub(self.idx, other.idx), self.ns)

    def __rsub__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Sub(other.idx, self.idx), self.ns)

    def __neg__(self):
        return _IndexedObject(self.ns._Neg(self.idx), self.ns)

    def __mul__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Mul2(self.idx, other.idx), self.ns)

    def __rmul__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Mul2(other.idx, self.idx), self.ns)

    def __truediv__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Div(self.idx, other.idx), self.ns)

    def __rtruediv__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Div(other.idx, self.idx), self.ns)

    def __pow__(self, exponent):
        exponent = _implicit_conversion(self.ns, exponent)
        return _IndexedObject(self.ns._Pow(self.idx, exponent.idx), self.ns)

    def evalb(self, inp):
        return self.ns.evalb(self.idx, inp)

    def evalf(self, inp):
        return self.ns.evalf(self.idx, inp)

    def diff(self, wrt):
        return _IndexedObject(self.ns.diff(self.idx, wrt.idx), self.ns)


def _implicit_conversion(ns, other):
    if isinstance(other, _IndexedObject):  # or look for 'ns' and 'idx'?
        assert other.ns == ns
        return other
    elif isinstance(other, int):
        return _IndexedObject(ns.make_integer(other), ns)
    elif isinstance(other, float):
        return _IndexedObject(ns.make_float(other), ns)
    else:
        raise NotImplementedError


cdef class PyNameSpace:
    cdef unique_ptr[NameSpace] thisptr
    cdef readonly vector[string] symbol_names
    cdef readonly object pi, neg_pi, E, neg_E

    def __cinit__(self, idx_t n=0, alloc=True):
        if alloc:
            self.thisptr = make_unique_NameSpace(n)

    def __init__(self, *args, **kwargs):
        self.pi = _IndexedObject(deref(self.thisptr).pi_id, self)
        self.neg_pi = _IndexedObject(deref(self.thisptr).neg_pi_id, self)
        self.E = _IndexedObject(deref(self.thisptr).e_id, self)
        self.neg_E = _IndexedObject(deref(self.thisptr).neg_e_id, self)

    property n_symbs:
        def __get__(self):
            return deref(self.thisptr).n_symbs

    def make_symbol(self, symb_idx):
        return deref(self.thisptr).make_symbol(symb_idx)

    def make_integer(self, intgr):
        return deref(self.thisptr).make_integer(intgr)

    def make_float(self, double dble):
        return deref(self.thisptr).make_float(dble)

    def make_nan(self):
        return deref(self.thisptr).make_nan()

    def make_matrix(self, nr, nc, data):
        return deref(self.thisptr).make_matrix(nr, nc, data)

    def matrix_jacobian(self, y, dx):
        return deref(self.thisptr).matrix_jacobian(y, dx)

    def matrix_get_nr(self, idx_t idx):
        return deref(self.thisptr).matrix_get_nr(idx)

    def matrix_get_nc(self, idx_t idx):
        return deref(self.thisptr).matrix_get_nc(idx)

    def matrix_evalf(self, idx_t idx, double[::1] inp, double[::1] out):
        mat_size = self.matrix_get_nr(idx) * self.matrix_get_nc(idx)
        if inp.size < deref(self.thisptr).n_symbs or out.size < mat_size:
            raise TypeError("Insufficient length")
        deref(self.thisptr).matrix_evalf(idx, &inp[0] if inp.size > 0 else NULL,
                                         &out[0] if out.size > 0 else NULL)

    def print_ast(self, idx):
        return deref(self.thisptr).print_ast(idx, self.symbol_names)

    def evalb(self, idx_t idx, double [::1] inp):
        return deref(self.thisptr).evalb(idx, &inp[0] if inp.size > 0 else NULL)

    def evalf(self, idx_t idx, double [::1] inp):
        return deref(self.thisptr).evalf(idx, &inp[0] if inp.size > 0 else NULL)

    def diff(self, idx0, idx1):
        return deref(self.thisptr).diff(idx0, idx1)

    # Unary:
%for Cls, Parent, meth in types_nonatomic_unary:
    def _${Cls}(self, idx):
        return deref(self.thisptr).${meth}(idx)

    def ${meth}(self, obj):
        obj = _implicit_conversion(self, obj)
        return _IndexedObject(self._${Cls}(obj.idx), self)
%endfor

    # Binary:
%for Cls, Parent, meth in types_nonatomic_binary:
    def _${Cls}(self, idx0, idx1):
        return deref(self.thisptr).${meth}(idx0, idx1)
    def ${meth}(self, obj0, obj1):
        obj0 = _implicit_conversion(self, obj0)
        obj1 = _implicit_conversion(self, obj1)
        return _IndexedObject(self._${Cls}(obj0.idx, obj1.idx), self)
%endfor

    def Number(self, val):
        if isinstance(val, int):
            return _IndexedObject(self.make_integer(val), self)
        else:
            return _IndexedObject(self.make_float(val), self)

    def Symbol(self, name):
        try:
            symb_nr = self.symbol_names.index(name)
        except ValueError:  # name not in list
            symb_nr = self.symbol_names.size()
        symb_idx = self.make_symbol(symb_nr)
        self.symbol_names.push_back(name if sys.version_info[0] == 2
                                    else bytes(name, encoding='utf-8'))
        return _IndexedObject(symb_idx, self)

    def symarray(self, prefix, shape, real=True):
        if real is not True:
            raise NotImplementedError
        arr = np.empty(shape, dtype=object)
        for index in np.ndindex(shape):
            arr[index] = self.Symbol('%s_%s' % (
                prefix, '_'.join(map(str, index))))
        return arr

    def Matrix(self, nr, nc, source, flat_output=False):
        if callable(source):
            callback = source
        else:
            def callback(ri, ci):
                try:
                    return source[ri, ci].idx
                except TypeError:
                    try:
                        return source[ri][ci].idx
                    except TypeError:
                        return source[ri*nc + ci].idx
        data = [callback(ri, ci) for ri, ci
                in itertools.product(range(nr), range(nc))]
        mat_idx = self.make_matrix(nr, nc, data)
        return _Matrix(mat_idx, self, flat_output)

    cdef _Matrix rebuild(self, args, _Matrix mtx, flat_output=False):
        cdef PyNameSpace new_ns = PyNameSpace(alloc=False)
        new_ns.thisptr = deref(self.thisptr).rebuild_from_matrix([arg.idx for arg in args], mtx.idx)
        return _Matrix(deref(new_ns.thisptr).get_instances_size()-1, new_ns, flat_output)

    def Lambdify(self, args, exprs):
        flat_output = False
        if not isinstance(exprs, _Matrix):
            try:
                exprs = self.Matrix(*exprs.shape, exprs)
            except AttributeError:
                try:
                    exprs = self.Matrix(len(exprs), 1, exprs)
                    flat_output = True
                except TypeError:
                    exprs = self.Matrix(1, 1, [exprs])  # single expression
        try:
            len(args)
        except TypeError:
            args = [args]  # single arg
        mtx = self.rebuild(args, exprs, flat_output=flat_output)
        return mtx.evalf

    def lambdify(self, args, exprs):
        Lmb = self.Lambdify(args, exprs)
        return lambda *args: Lmb(args)

    def symbols(self, args):
        return tuple([self.Symbol(arg) for arg in args.split()])
