# -*- coding: utf-8 -*-
# distutils: language = c++
# distutils: extra_compile_args = -std=c++11 -I./include

<%doc>
# This is a templated source file.
# Render template using Mako (Python templating engine)
</%doc>
# ${_message_for_rendered}

from libcpp cimport bool
from libcpp.vector cimport vector
from libcpp.string cimport string

ctypedef unsigned int idx_t

import itertools
import sys

import numpy as np

# TODO: use create(..., ) rather than raw methods. (will require C api)

cdef extern from "symcxx/core.hpp" namespace "symcxx":
    cdef cppclass NameSpace:
        idx_t n_symbs

        const idx_t pi_id
        const idx_t neg_pi_id
        const idx_t e_id
        const idx_t neg_e_id

        NameSpace(idx_t)
        idx_t make_symbol(idx_t)
        idx_t make_integer(int)
        idx_t make_float(double)
        idx_t make_nan()
        idx_t make_matrix(idx_t, idx_t, vector[idx_t]);
        idx_t matrix_jacobian(idx_t, idx_t) except +
        void matrix_evalf(idx_t, const double * const, double * const) except +
        idx_t matrix_get_nr(idx_t) const
        idx_t matrix_get_nc(idx_t) const
        string print_ast(const idx_t, vector[string]&) except +

        bool evalb(idx_t, const double *) except +
        double evalf(idx_t, const double *) except +
        idx_t diff(const idx_t, const idx_t) except +

%for Cls, Parent, meth in types_nonatomic_unary:
        idx_t ${meth}(idx_t)
%endfor

%for Cls, Parent, meth in types_nonatomic_binary:
        idx_t ${meth}(idx_t, idx_t)
%endfor

class _Matrix(object):

    def __init__(self, idx, namespace):
        self.idx = idx
        self.ns = namespace

    @property
    def shape(self):
        return (self.ns.matrix_get_nr(self.idx),
                self.ns.matrix_get_nc(self.idx))

    def jacobian(self, other):
        return _Matrix(self.ns.matrix_jacobian(self.idx, other.idx), self.ns)

    def evalf(self, inp, out=None):
        if out is None:
            out = np.empty(self.shape)
        local_out = np.ravel(out)
        self.ns.matrix_evalf(self.idx, inp, local_out)
        return local_out.reshape(self.shape)


class _IndexedObject(object):

    def __init__(self, idx, namespace, **kwargs):
        self.idx = idx
        self.ns = namespace
        self.__dict__.update(kwargs)

    def __eq__(self, other):
        other = _implicit_conversion(self.ns, other)
        if self.idx == other.idx and self.ns == other.ns:
            return True
        else:
            return False

    def __str__(self):
        return self.ns.print_ast(self.idx).decode('utf-8')

    def __add__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Add2(self.idx, other.idx), self.ns)

    def __radd__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Add2(other.idx, self.idx), self.ns)

    def __sub__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Sub(self.idx, other.idx), self.ns)

    def __rsub__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Sub(other.idx, self.idx), self.ns)

    def __mul__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Mul2(self.idx, other.idx), self.ns)

    def __rmul__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Mul2(other.idx, self.idx), self.ns)

    def __truediv__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Div(self.idx, other.idx), self.ns)

    def __rtruediv__(self, other):
        other = _implicit_conversion(self.ns, other)
        return _IndexedObject(self.ns._Div(other.idx, self.idx), self.ns)

    def evalb(self, inp):
        return self.ns.evalb(self.idx, inp)

    def evalf(self, inp):
        return self.ns.evalf(self.idx, inp)

    def diff(self, wrt):
        return _IndexedObject(self.ns.diff(self.idx, wrt.idx), self.ns)


def _implicit_conversion(ns, other):
    if isinstance(other, _IndexedObject):  # or look for 'ns' and 'idx'?
        assert other.ns == ns
        return other
    elif isinstance(other, int):
        return _IndexedObject(ns.make_integer(other), ns)
    elif isinstance(other, float):
        return _IndexedObject(ns.make_float(other), ns)
    else:
        raise NotImplementedError


cdef class PyNameSpace:
    cdef NameSpace *thisptr
    cdef readonly vector[string] symbol_names
    cdef readonly object pi, neg_pi, E, neg_E

    def __cinit__(self, idx_t n=0):
        self.thisptr = new NameSpace(n)
        self.pi = _IndexedObject(self.thisptr.pi_id, self)
        self.neg_pi = _IndexedObject(self.thisptr.neg_pi_id, self)
        self.E = _IndexedObject(self.thisptr.e_id, self)
        self.neg_E = _IndexedObject(self.thisptr.neg_e_id, self)

    def __dealloc__(self):
        del self.thisptr

    property n_symbs:
        def __get__(self):
            return self.thisptr.n_symbs

    def make_symbol(self, symb_idx):
        return self.thisptr.make_symbol(symb_idx)

    def make_integer(self, intgr):
        return self.thisptr.make_integer(intgr)

    def make_float(self, double dble):
        return self.thisptr.make_float(dble)

    def make_nan(self):
        return self.thisptr.make_nan()

    def make_matrix(self, nr, nc, data):
        return self.thisptr.make_matrix(nr, nc, data)

    def matrix_jacobian(self, y, dx):
        return self.thisptr.matrix_jacobian(y, dx)

    def matrix_get_nr(self, idx_t idx):
        return self.thisptr.matrix_get_nr(idx)

    def matrix_get_nc(self, idx_t idx):
        return self.thisptr.matrix_get_nc(idx)

    def matrix_evalf(self, idx_t idx, double[::1] inp, double[::1] out):
        mat_size = self.matrix_get_nr(idx) * self.matrix_get_nc(idx)
        if inp.size < self.thisptr.n_symbs or out.size < mat_size:
            raise ValueError("Insufficient length")
        self.thisptr.matrix_evalf(idx, &inp[0], &out[0])

    def print_ast(self, idx):
        return self.thisptr.print_ast(idx, self.symbol_names)

    def evalb(self, idx_t idx, double [::1] inp):
        return self.thisptr.evalb(idx, &inp[0])

    def evalf(self, idx_t idx, double [::1] inp):
        return self.thisptr.evalf(idx, &inp[0])

    def diff(self, idx0, idx1):
        return self.thisptr.diff(idx0, idx1)

    # Unary:
%for Cls, Parent, meth in types_nonatomic_unary:
    def _${Cls}(self, idx):
        return self.thisptr.${meth}(idx)

    def ${meth}(self, obj):
        obj = _implicit_conversion(self, obj)
        return _IndexedObject(self._${Cls}(obj.idx), self)
%endfor

    # Binary:
%for Cls, Parent, meth in types_nonatomic_binary:
    def _${Cls}(self, idx0, idx1):
        return self.thisptr.${meth}(idx0, idx1)
    def ${meth}(self, obj0, obj1):
        obj0 = _implicit_conversion(self, obj0)
        obj1 = _implicit_conversion(self, obj1)
        return _IndexedObject(self._${Cls}(obj0.idx, obj1.idx), self)
%endfor

    def Number(self, val):
        if isinstance(val, int):
            return _IndexedObject(self.make_integer(val), self)
        else:
            return _IndexedObject(self.make_float(val), self)

    def Symbol(self, name):
        symb_idx = self.make_symbol(self.symbol_names.size())
        self.symbol_names.push_back(name if sys.version_info[0] == 2
                                    else bytes(name, encoding='utf-8'))
        return _IndexedObject(symb_idx, self)

    def symarray(self, prefix, shape, real=True):
        if real is not True:
            raise NotImplementedError
        arr = np.empty(shape, dtype=object)
        for index in np.ndindex(shape):
            arr[index] = self.Symbol('%s_%s' % (
                prefix, '_'.join(map(str, index))))
        return arr

    def Matrix(self, nr, nc, source):
        if callable(source):
            callback = source
        else:
            def callback(ri, ci):
                try:
                    return source[ri, ci].idx
                except TypeError:
                    try:
                        return source[ri][ci].idx
                    except TypeError:
                        return source[ri*nc + ci].idx
        data = [callback(ri, ci) for ri, ci
                in itertools.product(range(nr), range(nc))]
        print(nr, nc, data)
        mat_idx = self.make_matrix(nr, nc, data)
        return _Matrix(mat_idx, self)
